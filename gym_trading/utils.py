import numpy as npdef get_price_list(flow):    price_list = []    column_index = [i*2 for i in range(0,flow.shape[1]//2)]    for i in range(flow.shape[0]):        price_list.extend(flow.iloc[i,column_index].to_list())    price_set = set(price_list)    price_list = sorted(list(price_set), reverse = True)    return price_listdef get_adjusted_obs(stream, price_list):    result = [0 for _ in range(len(price_list))]    for i in range(len(price_list)):        for j in range(stream.shape[0]//2):            if price_list[i] == stream.iloc[j*2]:                result[i] = stream.iloc[j*2+1]    return result def get_max_quantity(flow):    price_list = []    column_index = [i*2 + 1 for i in range(0,flow.shape[1]//2)]    for i in range(flow.shape[0]):        price_list.extend(flow.iloc[i,column_index].to_list())    price_set = max(price_list)    return price_setdef get_quantity_from_stream(stream):    column_index = [i*2 + 1 for i in range(0,stream.shape[0]//2)]    return stream.iloc[column_index].to_list()def get_price_from_stream(stream):    column_index = [i*2 for i in range(0,stream.shape[0]//2)]    return stream.iloc[column_index].to_list()def from_pairs2lst_pairs(pairs):    lst = [[],[]]    for pair in pairs:        # if type(pair) == int: pair = np.expand_dims(pair,axis=0)        try:            lst[0].append(pair[0])            lst[1].append(pair[1])        except: pass    return lstdef from_series2obs(series):    price_level = 10    min_price = 31120200 # TODO refered from BaseEnv    dictionary = {        'price':np.array([min_price for _ in range(price_level)]).astype(np.int32),        'quantity':np.array([0 for _ in range(price_level)]).astype(np.int32)        }    for i in range(min(len(series)//2, price_level)):        # as prices could be 11 or 12 which is more than current price level        dictionary['price'][i] = series.iloc[2*i]        dictionary['quantity'][i] = series.iloc[2*i+1]        # print("series.iloc[2*i+1] : ",series.iloc[2*i+1])    return dictionarydef timing(f):    from functools import wraps    from time import time    @wraps(f)    def wrap(*args, **kw):        ts = time()        result = f(*args, **kw)        te = time()        print('func:%r args:[%r, %r] took: %2.4f sec' %(f.__name__, args, kw, te-ts))        return result    return wrap# def exit_after():#     '''#     use as decorator to exit process if #     function takes longer than s seconds#     '''#     # from __future__ import print_function#     s = 10#     import sys#     import threading#     from time import sleep#     try:#         import thread#     except ImportError:#         import _thread as thread#     def quit_function(fn_name):#         # print to stderr, unbuffered in Python 2.#         print('{0} took too long'.format(fn_name), file=sys.stderr)#         sys.stderr.flush() # Python 3 stderr is likely buffered.#         thread.interrupt_main() # raises KeyboardInterrupt#     def outer(fn):#         def inner(*args, **kwargs):#             timer = threading.Timer(s, quit_function, args=[fn.__name__])#             timer.start()#             try:#                 result = fn(*args, **kwargs)#             finally:#                 timer.cancel()#             return result#         return inner#     return outerdef exit_after(fn):    '''    use as decorator to exit process if     function takes longer than s seconds    '''    # from __future__ import print_function    s = 60    import sys    import threading    from time import sleep    try:        import thread    except ImportError:        import _thread as thread    def quit_function(fn_name):        # print to stderr, unbuffered in Python 2.        print('{0} took too long'.format(fn_name), file=sys.stderr)        sys.stderr.flush() # Python 3 stderr is likely buffered.        thread.interrupt_main() # raises KeyboardInterrupt    def inner(*args, **kwargs):        timer = threading.Timer(s, quit_function, args=[fn.__name__])        timer.start()        try:            result = fn(*args, **kwargs)        finally:            timer.cancel()        return result    return inner# an example of the countdown decorator# @exit_after(5)# def countdown(n):#     print('countdown started', flush=True)#     for i in range(n, -1, -1):#         print(i, end=', ', flush=True)#         sleep(1)#     print('countdown finished')    if __name__=="__main__":    pairs = [[123,1],[133324,1],[132312,3]]##    # series = observation[0]            