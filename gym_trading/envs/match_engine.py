# %%
import copy
import numpy as np
# import cudf
import pandas as pd

from gym_trading.utils import Utils
from gym_trading.envs.broker import Flag, Broker
from gym_trading.data.data_pipeline import ExternalData
'''One Match Engine is corresponds to one specific Limit Order Book DataSet'''
# %%
class Core():
    init_index = 0
    def __init__(self, flow):
        # these wont be changed during step
        self._max_episode_steps = Flag.max_episode_steps 
        self.flow = flow
        # self._flow = -self.flow.diff()
        self._flow  = -np.diff(self.flow, axis = 0) # self._flow[index,:] comes from diff(flow[index+1,:], flow[index,:])

        # these will be changed during step
        self.index = None
        self.state = None
        self.action = None
        self.reward = None
        self.executed_pairs = None
        self.executed_quantity = None
        self.executed_sum = None
        self.done = None

    def update(self, obs, diff_obs):
        '''update at time index based on the observation of index-1'''
        obs.extend(diff_obs)
        if len(obs) == 0 :
            return []
        elif -999 in obs: 
            raise NotImplementedError
            # return [] # TODO to implement it in right way
        else:
            return Utils.remove_replicate(sorted(obs))
    def step(self, action):
        print("(match_engine) current index is ",self.index) ## tbd
        self.action = action
        self_state = self.state # tbd
        state = Utils.from_series2pair(self.state)

        assert type(action) == np.ndarray or int
        remove_zero_quantity = lambda x:[item for index, item in enumerate(x) if item[1]!=0]
        state = remove_zero_quantity(state)
        
        # action = min(action,self.num_left) ##
        
        new_obs, executed_quantity = Broker.pairs_market_order_liquidating(action, state)
        self.executed_quantity = executed_quantity
        # get_new_obs which are new orders, not the new state
        

        for item in new_obs:
            assert item[1] <= 0 
        self.executed_pairs = new_obs ## TODO ERROR
        ''' e.g. [[31161600, -3], [31160000, -4], [31152200, -13]] 
        all the second element should be negative, as it is the excuted and should be
        removed from the limit order book
        '''
        
        if sum([-1*item[-1] for item in new_obs]) != executed_quantity:
            '''the left is the sum of the quantity from new_obs'''
            num, obs = executed_quantity, [[item[0],-1*item[1]] for item in new_obs]
            result, executed_num = Broker.pairs_market_order_liquidating(num, obs)
            assert executed_num == executed_quantity
            self.executed_pairs = result
        # get the executed_pairs
        
        # diff_obs = self.diff(self.index-1)
        state = sorted(state, reverse = True) # state is the original observation 1/3
        
        self_index = self.index # tbd
        diff_obs = self.get_difference(Flag.skip) # get incomming orders from data 2/3
        to_be_updated = self.update(diff_obs, new_obs) # new_obs is generated by action 2/3
        
        updated_state = self.update(state, to_be_updated) # updated state, state combined with incomming orders 3/3
        
        # def check_get_difference_and_update(): 
        if len(diff_obs)!= 0: # diff_obs: get incomming orders from data 2/3
        # if len(to_be_updated)!= 0:
            right_answer = self.flow[self.index,:] # it should be this one
            right_answer_m1 = self.flow[self.index-1,:]
            right_answer_p1 = self.flow[self.index+1,:]
            my_answer = sorted(updated_state,reverse=True)
            # breakpoint()
            print() #tbd
        
        if type(updated_state) == list:
            # updated_state = self.check_positive(updated_state) # todo delete check_positive
            def check_positive_and_remove_zero(updated_state):
                result= []
                for index, item in enumerate(updated_state):
                    if item[1] < 0: # todo check here if it should be negative # checking? here it should be negative
                        result.append(item)
                return result
            def keep_dimension(updated_state,size):
                updated_state = sorted(updated_state, reverse = True)
                if len(updated_state) > size: updated_state = updated_state[:size]
                if len(updated_state) < size: updated_state.extend([[Flag.min_price,0] for i in range(size - len(updated_state))])
                return updated_state
                
            print("action chosen in this step ",self.action) # tbd
            print("core.index in this step ", self.index) # tbd
            minus_flow = self._flow # tbd
            origin_flow = self.flow[self.index,:];print('origin_flow ',origin_flow) # tbd
            try: diff_flow = self._flow[self.index-1,:]; print('diff_flow ',diff_flow) # tbd
            except: pass
            print('diff_obs ', diff_obs) # tbd
            
            updated_state_1 = check_positive_and_remove_zero(updated_state) # tbd
            # updated_state = keep_dimension(updated_state,self.flow.shape[1]//2) # tbd
            updated_state_2 = Utils.from_pair2series(updated_state_1) # tbd
            
            updated_state = check_positive_and_remove_zero(updated_state) 
            updated_state = keep_dimension(updated_state,self.flow.shape[1]//2)
            updated_state = Utils.from_pair2series(updated_state)
            
        self.state = updated_state
        reward = self.reward
        self.done = self.check_done()
        self.executed_sum += self.executed_quantity # add this line to check if all liquidated
        # ---------------------
        self.index += Flag.skip # default = 1, change the index before return
        return self.state, reward, self.done, {}
    
    def get_difference(self, skip = 1):
        Index = copy.deepcopy(self.index)
        diff_list = []
        for i in range((self._flow.shape[1])//2): # in range of col_num
            for Index in range(self.index, self.index + skip):
                if Index >= self._max_episode_steps: break # TODO should implement in right way
                if self._flow[Index, 2*i] != 0 or self._flow[Index, 2*i+1] !=0:
                    diff_list.extend([
                        [self.flow[Index+1,2*i], self.flow[Index+1,2*i+1]], 
                        [self.flow[Index,2*i], -self.flow[Index,2*i+1]]
                        ])
        if len(diff_list) == 0: return []
        else: return Utils.remove_replicate(sorted(diff_list))  
        '''e.g.
        If Index == 3 in the single_file_debug mode, the the incomming difference order 
        from data should be [[31120200, -35], [31155000, 28]], which means withdrawing 
        35 of 31120200, and incomming 28 of 31155000.
        '''
    
    def check_done(self):
        if self.index < self._max_episode_steps: return False
        elif self.index == self._max_episode_steps: return True
    
    def reset(self):
        self.index = Core.init_index # default = 0
        self.state = self.flow[Core.init_index,:] #initial_state
        # self.state = self.flow.iloc[Core.init_index,:] #initial_state
        self.action = None
        self.executed_pairs = None
        self.executed_quantity = None
        self.done = False
        self.executed_sum = 0
        return self.state
    
    
    def get_ceilling(self):
        next_stage = self.state
        next_stage_lst = list(next_stage)
        result = 0.0
        for i in range(len(next_stage_lst)):
            if i % 2 == 1:
                result += next_stage_lst[i]
        return result
    
    def check_positive(self, updated_state):
        for item in updated_state:
            if item[1]<0:
                item[1]=0
        return updated_state
        
# %%
if __name__ == "__main__":
    Flow = ExternalData.get_sample_order_book_data()
    flow = Flow.iloc[0:Flag.max_episode_steps,:].reset_index().drop("index",axis=1)
    flow = flow.to_numpy()

    core = Core(flow)
    obs0 = core.reset()
    
    
    for i in range(10):
        obs = core.step(0)
        
    for i in range(10):
        obs = core.step(1)
    # ==================================================
    obs125= core.step(min(20,core.get_ceilling()))
    obs126 = core.step(300)
    # ==================================================
    

    